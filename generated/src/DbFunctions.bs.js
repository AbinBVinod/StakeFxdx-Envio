// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Types = require("./Types.bs.js");
var Config = require("./Config.bs.js");
var Logging = require("./Logging.bs.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Postgres = require("postgres");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var DbFunctionsImplementationJs = require("./DbFunctionsImplementation.js");

var newrecord = Caml_obj.obj_dup(Config.db);

newrecord.transform = {
  undefined: null
};

var sql = Postgres(newrecord);

function setChainMetadata(prim0, prim1) {
  return DbFunctionsImplementationJs.setChainMetadata(prim0, prim1);
}

function setChainMetadataRow(chainId, startBlock, blockHeight) {
  return DbFunctionsImplementationJs.setChainMetadata(sql, {
              chain_id: chainId,
              block_height: blockHeight,
              start_block: startBlock
            });
}

var ChainMetadata = {
  setChainMetadata: setChainMetadata,
  setChainMetadataRow: setChainMetadataRow
};

function readLatestSyncedEventOnChainIdArr(prim0, prim1) {
  return DbFunctionsImplementationJs.readLatestSyncedEventOnChainId(prim0, prim1);
}

async function readLatestSyncedEventOnChainId(sql, chainId) {
  var arr = await DbFunctionsImplementationJs.readLatestSyncedEventOnChainId(sql, chainId);
  return Belt_Array.get(arr, 0);
}

async function getLatestProcessedBlockNumber(chainId) {
  var latestEventOpt = await readLatestSyncedEventOnChainId(sql, chainId);
  return Belt_Option.map(latestEventOpt, (function ($$event) {
                return $$event.block_number;
              }));
}

function batchSet(prim0, prim1) {
  return DbFunctionsImplementationJs.batchSetEventSyncState(prim0, prim1);
}

var EventSyncState = {
  readLatestSyncedEventOnChainIdArr: readLatestSyncedEventOnChainIdArr,
  readLatestSyncedEventOnChainId: readLatestSyncedEventOnChainId,
  getLatestProcessedBlockNumber: getLatestProcessedBlockNumber,
  batchSet: batchSet
};

function batchSet$1(prim0, prim1) {
  return DbFunctionsImplementationJs.batchSetRawEvents(prim0, prim1);
}

function batchDelete(prim0, prim1) {
  return DbFunctionsImplementationJs.batchDeleteRawEvents(prim0, prim1);
}

function readEntities(prim0, prim1) {
  return DbFunctionsImplementationJs.readRawEventsEntities(prim0, prim1);
}

function getRawEventsPageGtOrEqEventId(prim0, prim1, prim2, prim3, prim4) {
  return DbFunctionsImplementationJs.getRawEventsPageGtOrEqEventId(prim0, prim1, prim2, prim3, prim4);
}

function getRawEventsPageWithinEventIdRangeInclusive(prim0, prim1, prim2, prim3, prim4, prim5) {
  return DbFunctionsImplementationJs.getRawEventsPageWithinEventIdRangeInclusive(prim0, prim1, prim2, prim3, prim4, prim5);
}

function readLatestRawEventsBlockNumberProcessedOnChainId(prim0, prim1) {
  return DbFunctionsImplementationJs.readLatestRawEventsBlockNumberProcessedOnChainId(prim0, prim1);
}

async function getLatestProcessedBlockNumber$1(chainId) {
  var row = await DbFunctionsImplementationJs.readLatestRawEventsBlockNumberProcessedOnChainId(sql, chainId);
  return Belt_Option.map(Belt_Array.get(row, 0), (function (row) {
                return row.block_number;
              }));
}

var RawEvents = {
  batchSet: batchSet$1,
  batchDelete: batchDelete,
  readEntities: readEntities,
  getRawEventsPageGtOrEqEventId: getRawEventsPageGtOrEqEventId,
  getRawEventsPageWithinEventIdRangeInclusive: getRawEventsPageWithinEventIdRangeInclusive,
  readLatestRawEventsBlockNumberProcessedOnChainId: readLatestRawEventsBlockNumberProcessedOnChainId,
  getLatestProcessedBlockNumber: getLatestProcessedBlockNumber$1
};

function batchSet$2(prim0, prim1) {
  return DbFunctionsImplementationJs.batchSetDynamicContractRegistry(prim0, prim1);
}

function batchDelete$1(prim0, prim1) {
  return DbFunctionsImplementationJs.batchDeleteDynamicContractRegistry(prim0, prim1);
}

function readEntities$1(prim0, prim1) {
  return DbFunctionsImplementationJs.readDynamicContractRegistryEntities(prim0, prim1);
}

function readDynamicContractsOnChainIdAtOrBeforeBlock(prim0, prim1, prim2) {
  return DbFunctionsImplementationJs.readDynamicContractsOnChainIdAtOrBeforeBlock(prim0, prim1, prim2);
}

var DynamicContractRegistry = {
  batchSet: batchSet$2,
  batchDelete: batchDelete$1,
  readEntities: readEntities$1,
  readDynamicContractsOnChainIdAtOrBeforeBlock: readDynamicContractsOnChainIdAtOrBeforeBlock
};

function decodeUnsafe(entityJson) {
  var v = Types.eventsSummaryEntity_decode(entityJson);
  var tmp;
  if (v.TAG === /* Ok */0) {
    tmp = {
      TAG: /* Ok */0,
      _0: v._0
    };
  } else {
    var e = v._0;
    Logging.error({
          err: e,
          msg: "EE700: Unable to parse row from database of entity eventsSummary using spice",
          raw_unparsed_object: entityJson
        });
    tmp = {
      TAG: /* Error */1,
      _0: e
    };
  }
  return Belt_Result.getExn(tmp);
}

function batchSet$3(prim0, prim1) {
  return DbFunctionsImplementationJs.batchSetEventsSummary(prim0, prim1);
}

function batchDelete$2(prim0, prim1) {
  return DbFunctionsImplementationJs.batchDeleteEventsSummary(prim0, prim1);
}

function readEntitiesFromDb(prim0, prim1) {
  return DbFunctionsImplementationJs.readEventsSummaryEntities(prim0, prim1);
}

async function readEntities$2(sql, ids) {
  var res = await DbFunctionsImplementationJs.readEventsSummaryEntities(sql, ids);
  return Belt_Array.map(res, decodeUnsafe);
}

var EventsSummary = {
  decodeUnsafe: decodeUnsafe,
  batchSet: batchSet$3,
  batchDelete: batchDelete$2,
  readEntitiesFromDb: readEntitiesFromDb,
  readEntities: readEntities$2
};

function decodeUnsafe$1(entityJson) {
  var v = Types.rewardFxdxVault_AddRewardEntity_decode(entityJson);
  var tmp;
  if (v.TAG === /* Ok */0) {
    tmp = {
      TAG: /* Ok */0,
      _0: v._0
    };
  } else {
    var e = v._0;
    Logging.error({
          err: e,
          msg: "EE700: Unable to parse row from database of entity rewardFxdxVault_AddReward using spice",
          raw_unparsed_object: entityJson
        });
    tmp = {
      TAG: /* Error */1,
      _0: e
    };
  }
  return Belt_Result.getExn(tmp);
}

function batchSet$4(prim0, prim1) {
  return DbFunctionsImplementationJs.batchSetRewardFxdxVault_AddReward(prim0, prim1);
}

function batchDelete$3(prim0, prim1) {
  return DbFunctionsImplementationJs.batchDeleteRewardFxdxVault_AddReward(prim0, prim1);
}

function readEntitiesFromDb$1(prim0, prim1) {
  return DbFunctionsImplementationJs.readRewardFxdxVault_AddRewardEntities(prim0, prim1);
}

async function readEntities$3(sql, ids) {
  var res = await DbFunctionsImplementationJs.readRewardFxdxVault_AddRewardEntities(sql, ids);
  return Belt_Array.map(res, decodeUnsafe$1);
}

var RewardFxdxVault_AddReward = {
  decodeUnsafe: decodeUnsafe$1,
  batchSet: batchSet$4,
  batchDelete: batchDelete$3,
  readEntitiesFromDb: readEntitiesFromDb$1,
  readEntities: readEntities$3
};

function decodeUnsafe$2(entityJson) {
  var v = Types.rewardFxdxVault_SendRewardEntity_decode(entityJson);
  var tmp;
  if (v.TAG === /* Ok */0) {
    tmp = {
      TAG: /* Ok */0,
      _0: v._0
    };
  } else {
    var e = v._0;
    Logging.error({
          err: e,
          msg: "EE700: Unable to parse row from database of entity rewardFxdxVault_SendReward using spice",
          raw_unparsed_object: entityJson
        });
    tmp = {
      TAG: /* Error */1,
      _0: e
    };
  }
  return Belt_Result.getExn(tmp);
}

function batchSet$5(prim0, prim1) {
  return DbFunctionsImplementationJs.batchSetRewardFxdxVault_SendReward(prim0, prim1);
}

function batchDelete$4(prim0, prim1) {
  return DbFunctionsImplementationJs.batchDeleteRewardFxdxVault_SendReward(prim0, prim1);
}

function readEntitiesFromDb$2(prim0, prim1) {
  return DbFunctionsImplementationJs.readRewardFxdxVault_SendRewardEntities(prim0, prim1);
}

async function readEntities$4(sql, ids) {
  var res = await DbFunctionsImplementationJs.readRewardFxdxVault_SendRewardEntities(sql, ids);
  return Belt_Array.map(res, decodeUnsafe$2);
}

var RewardFxdxVault_SendReward = {
  decodeUnsafe: decodeUnsafe$2,
  batchSet: batchSet$5,
  batchDelete: batchDelete$4,
  readEntitiesFromDb: readEntitiesFromDb$2,
  readEntities: readEntities$4
};

function decodeUnsafe$3(entityJson) {
  var v = Types.rewardFxdxVault_TotalReservesEntity_decode(entityJson);
  var tmp;
  if (v.TAG === /* Ok */0) {
    tmp = {
      TAG: /* Ok */0,
      _0: v._0
    };
  } else {
    var e = v._0;
    Logging.error({
          err: e,
          msg: "EE700: Unable to parse row from database of entity rewardFxdxVault_TotalReserves using spice",
          raw_unparsed_object: entityJson
        });
    tmp = {
      TAG: /* Error */1,
      _0: e
    };
  }
  return Belt_Result.getExn(tmp);
}

function batchSet$6(prim0, prim1) {
  return DbFunctionsImplementationJs.batchSetRewardFxdxVault_TotalReserves(prim0, prim1);
}

function batchDelete$5(prim0, prim1) {
  return DbFunctionsImplementationJs.batchDeleteRewardFxdxVault_TotalReserves(prim0, prim1);
}

function readEntitiesFromDb$3(prim0, prim1) {
  return DbFunctionsImplementationJs.readRewardFxdxVault_TotalReservesEntities(prim0, prim1);
}

async function readEntities$5(sql, ids) {
  var res = await DbFunctionsImplementationJs.readRewardFxdxVault_TotalReservesEntities(sql, ids);
  return Belt_Array.map(res, decodeUnsafe$3);
}

var RewardFxdxVault_TotalReserves = {
  decodeUnsafe: decodeUnsafe$3,
  batchSet: batchSet$6,
  batchDelete: batchDelete$5,
  readEntitiesFromDb: readEntitiesFromDb$3,
  readEntities: readEntities$5
};

function decodeUnsafe$4(entityJson) {
  var v = Types.stakedFxdxVault_StakeEntity_decode(entityJson);
  var tmp;
  if (v.TAG === /* Ok */0) {
    tmp = {
      TAG: /* Ok */0,
      _0: v._0
    };
  } else {
    var e = v._0;
    Logging.error({
          err: e,
          msg: "EE700: Unable to parse row from database of entity stakedFxdxVault_Stake using spice",
          raw_unparsed_object: entityJson
        });
    tmp = {
      TAG: /* Error */1,
      _0: e
    };
  }
  return Belt_Result.getExn(tmp);
}

function batchSet$7(prim0, prim1) {
  return DbFunctionsImplementationJs.batchSetStakedFxdxVault_Stake(prim0, prim1);
}

function batchDelete$6(prim0, prim1) {
  return DbFunctionsImplementationJs.batchDeleteStakedFxdxVault_Stake(prim0, prim1);
}

function readEntitiesFromDb$4(prim0, prim1) {
  return DbFunctionsImplementationJs.readStakedFxdxVault_StakeEntities(prim0, prim1);
}

async function readEntities$6(sql, ids) {
  var res = await DbFunctionsImplementationJs.readStakedFxdxVault_StakeEntities(sql, ids);
  return Belt_Array.map(res, decodeUnsafe$4);
}

var StakedFxdxVault_Stake = {
  decodeUnsafe: decodeUnsafe$4,
  batchSet: batchSet$7,
  batchDelete: batchDelete$6,
  readEntitiesFromDb: readEntitiesFromDb$4,
  readEntities: readEntities$6
};

function decodeUnsafe$5(entityJson) {
  var v = Types.stakedFxdxVault_TotalReservesEntity_decode(entityJson);
  var tmp;
  if (v.TAG === /* Ok */0) {
    tmp = {
      TAG: /* Ok */0,
      _0: v._0
    };
  } else {
    var e = v._0;
    Logging.error({
          err: e,
          msg: "EE700: Unable to parse row from database of entity stakedFxdxVault_TotalReserves using spice",
          raw_unparsed_object: entityJson
        });
    tmp = {
      TAG: /* Error */1,
      _0: e
    };
  }
  return Belt_Result.getExn(tmp);
}

function batchSet$8(prim0, prim1) {
  return DbFunctionsImplementationJs.batchSetStakedFxdxVault_TotalReserves(prim0, prim1);
}

function batchDelete$7(prim0, prim1) {
  return DbFunctionsImplementationJs.batchDeleteStakedFxdxVault_TotalReserves(prim0, prim1);
}

function readEntitiesFromDb$5(prim0, prim1) {
  return DbFunctionsImplementationJs.readStakedFxdxVault_TotalReservesEntities(prim0, prim1);
}

async function readEntities$7(sql, ids) {
  var res = await DbFunctionsImplementationJs.readStakedFxdxVault_TotalReservesEntities(sql, ids);
  return Belt_Array.map(res, decodeUnsafe$5);
}

var StakedFxdxVault_TotalReserves = {
  decodeUnsafe: decodeUnsafe$5,
  batchSet: batchSet$8,
  batchDelete: batchDelete$7,
  readEntitiesFromDb: readEntitiesFromDb$5,
  readEntities: readEntities$7
};

function decodeUnsafe$6(entityJson) {
  var v = Types.stakedFxdxVault_UnstakeEntity_decode(entityJson);
  var tmp;
  if (v.TAG === /* Ok */0) {
    tmp = {
      TAG: /* Ok */0,
      _0: v._0
    };
  } else {
    var e = v._0;
    Logging.error({
          err: e,
          msg: "EE700: Unable to parse row from database of entity stakedFxdxVault_Unstake using spice",
          raw_unparsed_object: entityJson
        });
    tmp = {
      TAG: /* Error */1,
      _0: e
    };
  }
  return Belt_Result.getExn(tmp);
}

function batchSet$9(prim0, prim1) {
  return DbFunctionsImplementationJs.batchSetStakedFxdxVault_Unstake(prim0, prim1);
}

function batchDelete$8(prim0, prim1) {
  return DbFunctionsImplementationJs.batchDeleteStakedFxdxVault_Unstake(prim0, prim1);
}

function readEntitiesFromDb$6(prim0, prim1) {
  return DbFunctionsImplementationJs.readStakedFxdxVault_UnstakeEntities(prim0, prim1);
}

async function readEntities$8(sql, ids) {
  var res = await DbFunctionsImplementationJs.readStakedFxdxVault_UnstakeEntities(sql, ids);
  return Belt_Array.map(res, decodeUnsafe$6);
}

var StakedFxdxVault_Unstake = {
  decodeUnsafe: decodeUnsafe$6,
  batchSet: batchSet$9,
  batchDelete: batchDelete$8,
  readEntitiesFromDb: readEntitiesFromDb$6,
  readEntities: readEntities$8
};

var config = newrecord;

exports.config = config;
exports.sql = sql;
exports.ChainMetadata = ChainMetadata;
exports.EventSyncState = EventSyncState;
exports.RawEvents = RawEvents;
exports.DynamicContractRegistry = DynamicContractRegistry;
exports.EventsSummary = EventsSummary;
exports.RewardFxdxVault_AddReward = RewardFxdxVault_AddReward;
exports.RewardFxdxVault_SendReward = RewardFxdxVault_SendReward;
exports.RewardFxdxVault_TotalReserves = RewardFxdxVault_TotalReserves;
exports.StakedFxdxVault_Stake = StakedFxdxVault_Stake;
exports.StakedFxdxVault_TotalReserves = StakedFxdxVault_TotalReserves;
exports.StakedFxdxVault_Unstake = StakedFxdxVault_Unstake;
/*  Not a pure module */
