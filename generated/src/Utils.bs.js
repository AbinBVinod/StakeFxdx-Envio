// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

function mergeSorted(f, xs, ys) {
  if (xs.length === 0) {
    return ys;
  }
  if (ys.length === 0) {
    return xs;
  }
  var n = xs.length + ys.length | 0;
  var result = Array(n);
  var loop = function (_i, _j, _k) {
    while(true) {
      var k = _k;
      var j = _j;
      var i = _i;
      if (i < xs.length && j < ys.length) {
        if (Caml_obj.lessequal(Curry._1(f, Caml_array.get(xs, i)), Curry._1(f, Caml_array.get(ys, j)))) {
          Caml_array.set(result, k, Caml_array.get(xs, i));
          _k = k + 1 | 0;
          _i = i + 1 | 0;
          continue ;
        }
        Caml_array.set(result, k, Caml_array.get(ys, j));
        _k = k + 1 | 0;
        _j = j + 1 | 0;
        continue ;
      }
      if (i < xs.length) {
        Caml_array.set(result, k, Caml_array.get(xs, i));
        _k = k + 1 | 0;
        _i = i + 1 | 0;
        continue ;
      }
      if (j >= ys.length) {
        return ;
      }
      Caml_array.set(result, k, Caml_array.get(ys, j));
      _k = k + 1 | 0;
      _j = j + 1 | 0;
      continue ;
    };
  };
  loop(0, 0, 0);
  return result;
}

function createPromiseWithHandles(param) {
  var resolveRef = {
    contents: undefined
  };
  var rejectRef = {
    contents: undefined
  };
  var pendingPromise = new Promise((function (resolve, reject) {
          resolveRef.contents = resolve;
          rejectRef.contents = reject;
        }));
  var resolve = function (val) {
    var res = resolveRef.contents;
    res(val);
  };
  var reject = function (exn) {
    var rej = rejectRef.contents;
    rej(exn);
  };
  return {
          pendingPromise: pendingPromise,
          resolve: resolve,
          reject: reject
        };
}

function mapArrayOfResults(results) {
  return Belt_Array.reduce(results, {
              TAG: /* Ok */0,
              _0: []
            }, (function (accum, nextItem) {
                return Belt_Result.flatMap(accum, (function (currentOkItems) {
                              return Belt_Result.map(nextItem, (function (item) {
                                            return Belt_Array.concat(currentOkItems, [item]);
                                          }));
                            }));
              }));
}

function optionMapNone(opt, val) {
  if (opt !== undefined) {
    return ;
  } else {
    return Caml_option.some(val);
  }
}

function get(tuple, index) {
  return (tuple[index]);
}

var Tuple = {
  get: get
};

exports.mergeSorted = mergeSorted;
exports.createPromiseWithHandles = createPromiseWithHandles;
exports.mapArrayOfResults = mapArrayOfResults;
exports.optionMapNone = optionMapNone;
exports.Tuple = Tuple;
/* No side effect */
