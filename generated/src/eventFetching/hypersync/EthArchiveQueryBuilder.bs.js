// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Time = require("../../Time.bs.js");
var Utils = require("../../Utils.bs.js");
var Ethers = require("../../bindings/Ethers.bs.js");
var Ethers$1 = require("ethers");
var Logging = require("../../Logging.bs.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var EthArchive = require("./EthArchive.bs.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

function makeRequestBody(fromBlock, toBlock, addresses, topics) {
  return {
          fromBlock: fromBlock,
          toBlock: toBlock,
          logs: [{
              address: addresses,
              topics: topics,
              fieldSelection: {
                block: {
                  timestamp: true
                },
                log: {
                  address: true,
                  blockHash: true,
                  blockNumber: true,
                  data: true,
                  index: true,
                  removed: true,
                  topics: true,
                  transactionHash: true,
                  transactionIndex: true
                }
              }
            }]
        };
}

function convertResponse(res) {
  if (res.TAG !== /* Ok */0) {
    return {
            TAG: /* Error */1,
            _0: {
              TAG: /* QueryError */1,
              _0: res._0
            }
          };
  }
  var match = res._0;
  var nextBlock = match.nextBlock;
  var archiveHeight = match.archiveHeight;
  return Belt_Result.map(Utils.mapArrayOfResults(Belt_Array.flatMap(match.data, (function (inner) {
                        return Belt_Array.flatMap(inner, (function (item) {
                                      var match = item.block;
                                      var match$1 = item.logs;
                                      if (match !== undefined && match$1 !== undefined) {
                                        return Belt_Array.map(match$1, (function (log) {
                                                      var match$2 = match.timestamp;
                                                      var match$3 = log.address;
                                                      var match$4 = log.blockHash;
                                                      var match$5 = log.blockNumber;
                                                      var match$6 = log.data;
                                                      var match$7 = log.index;
                                                      var match$8 = log.transactionHash;
                                                      var match$9 = log.transactionIndex;
                                                      var match$10 = log.topics;
                                                      var match$11 = log.removed;
                                                      if (match$2 !== undefined && match$3 !== undefined && match$4 !== undefined && match$5 !== undefined && match$6 !== undefined && match$7 !== undefined && match$8 !== undefined && match$9 !== undefined && match$10 !== undefined && match$11 !== undefined) {
                                                        var log_address = Ethers$1.ethers.getAddress(match$3);
                                                        var log$1 = {
                                                          blockNumber: match$5,
                                                          blockHash: match$4,
                                                          removed: match$11,
                                                          address: log_address,
                                                          data: match$6,
                                                          topics: match$10,
                                                          transactionHash: match$8,
                                                          transactionIndex: match$9,
                                                          index: match$7
                                                        };
                                                        var blockTimestamp = Belt_Option.getExn(Belt_Int.fromString(Caml_option.valFromOption(match$2).toString()));
                                                        var pageItem = {
                                                          log: log$1,
                                                          blockTimestamp: blockTimestamp
                                                        };
                                                        return {
                                                                TAG: /* Ok */0,
                                                                _0: pageItem
                                                              };
                                                      }
                                                      var missingParams = Belt_Array.keepMap([
                                                            Utils.optionMapNone(match.timestamp, "log.timestamp"),
                                                            Utils.optionMapNone(log.address, "log.address"),
                                                            Utils.optionMapNone(log.blockHash, "log.blockHash-"),
                                                            Utils.optionMapNone(log.blockNumber, "log.blockNumber"),
                                                            Utils.optionMapNone(log.data, "log.data"),
                                                            Utils.optionMapNone(log.index, "log.index"),
                                                            Utils.optionMapNone(log.transactionHash, "log.transactionHash"),
                                                            Utils.optionMapNone(log.transactionIndex, "log.transactionIndex"),
                                                            Utils.optionMapNone(log.topics, "log.topics"),
                                                            Utils.optionMapNone(log.removed, "log.removed")
                                                          ], (function (v) {
                                                              return v;
                                                            }));
                                                      return {
                                                              TAG: /* Error */1,
                                                              _0: {
                                                                TAG: /* UnexpectedMissingParams */0,
                                                                _0: {
                                                                  queryName: "queryLogsPage EthArchive",
                                                                  missingParams: missingParams
                                                                }
                                                              }
                                                            };
                                                    }));
                                      }
                                      var missingParams = Belt_Array.keepMap([
                                            Utils.optionMapNone(item.block, "blocks"),
                                            Utils.optionMapNone(item.logs, "logs")
                                          ], (function (v) {
                                              return v;
                                            }));
                                      return [{
                                                TAG: /* Error */1,
                                                _0: {
                                                  TAG: /* UnexpectedMissingParams */0,
                                                  _0: {
                                                    queryName: "queryLogsPage EthArchive",
                                                    missingParams: missingParams
                                                  }
                                                }
                                              }];
                                    }));
                      }))), (function (items) {
                return {
                        items: items,
                        nextBlock: nextBlock,
                        archiveHeight: archiveHeight
                      };
              }));
}

async function queryLogsPage(serverUrl, fromBlock, toBlock, contractAddressesAndtopics) {
  var match = Belt_Array.reduce(contractAddressesAndtopics, [
        [],
        []
      ], (function (accum, item) {
          var newAddresses = Belt_Array.concat(accum[0], Belt_Option.getWithDefault(item.address, []));
          var newTopics = Belt_Array.concat(accum[1], Belt_Array.concatMany(item.topics));
          return [
                  newAddresses,
                  newTopics
                ];
        }));
  var body = makeRequestBody(fromBlock, toBlock, match[0], [match[1]]);
  return convertResponse(await EthArchive.executeEthArchiveQuery(serverUrl, body));
}

var LogsQuery = {
  makeRequestBody: makeRequestBody,
  convertResponse: convertResponse,
  queryLogsPage: queryLogsPage
};

function makeRequestBody$1(fromBlock, toBlock) {
  return {
          fromBlock: fromBlock,
          toBlock: toBlock,
          transactions: [{
              fieldSelection: {
                block: {
                  number: true,
                  timestamp: true
                }
              }
            }]
        };
}

function convertResponse$1(res) {
  if (res.TAG !== /* Ok */0) {
    return {
            TAG: /* Error */1,
            _0: {
              TAG: /* QueryError */1,
              _0: res._0
            }
          };
  }
  var successRes = res._0;
  var nextBlock = successRes.nextBlock;
  var archiveHeight = successRes.archiveHeight;
  return Belt_Result.map(Utils.mapArrayOfResults(Belt_Array.flatMap(successRes.data, (function (inner) {
                        return Belt_Array.map(inner, (function (item) {
                                      var match = item.block;
                                      if (match !== undefined) {
                                        var blockNumber = match.number;
                                        if (blockNumber !== undefined) {
                                          var blockTimestamp = match.timestamp;
                                          if (blockTimestamp !== undefined) {
                                            var timestamp = Belt_Option.getExn(Ethers.$$BigInt.toInt(Caml_option.valFromOption(blockTimestamp)));
                                            return {
                                                    TAG: /* Ok */0,
                                                    _0: {
                                                      timestamp: timestamp,
                                                      blockNumber: blockNumber
                                                    }
                                                  };
                                          }
                                          
                                        }
                                        
                                      }
                                      var missingParams = Belt_Array.keepMap([
                                            Utils.optionMapNone(item.block, "block"),
                                            Utils.optionMapNone(Belt_Option.flatMap(item.block, (function (block) {
                                                        return block.number;
                                                      })), "block.number"),
                                            Utils.optionMapNone(Belt_Option.flatMap(item.block, (function (block) {
                                                        return block.timestamp;
                                                      })), "block.timestamp")
                                          ], (function (p) {
                                              return p;
                                            }));
                                      return {
                                              TAG: /* Error */1,
                                              _0: {
                                                TAG: /* UnexpectedMissingParams */0,
                                                _0: {
                                                  queryName: "queryBlockTimestampsPage EthArchive",
                                                  missingParams: missingParams
                                                }
                                              }
                                            };
                                    }));
                      }))), (function (items) {
                return {
                        items: items,
                        nextBlock: nextBlock,
                        archiveHeight: archiveHeight
                      };
              }));
}

async function queryBlockTimestampsPage(serverUrl, fromBlock, toBlock) {
  var body = makeRequestBody$1(fromBlock, toBlock);
  return convertResponse$1(await EthArchive.executeEthArchiveQuery(serverUrl, body));
}

var BlockTimestampQuery = {
  makeRequestBody: makeRequestBody$1,
  convertResponse: convertResponse$1,
  queryBlockTimestampsPage: queryBlockTimestampsPage
};

async function getHeightWithRetry(serverUrl, logger) {
  var retryIntervalMillis = 500;
  var height = 0;
  while(height <= 0) {
    var res = await EthArchive.getArchiveHeight(serverUrl);
    if (res.TAG === /* Ok */0) {
      height = res._0;
    } else {
      Logging.childWarn(logger, {
            message: "Failed to get height from endpoint. Retrying in " + String(retryIntervalMillis) + "ms...",
            error: res._0
          });
      await Time.resolvePromiseAfterDelay(retryIntervalMillis);
      retryIntervalMillis = (retryIntervalMillis << 1);
    }
  };
  return height;
}

async function pollForHeightGtOrEq(serverUrl, blockNumber, logger) {
  var pollHeight = await getHeightWithRetry(serverUrl, logger);
  while(pollHeight <= blockNumber) {
    await Time.resolvePromiseAfterDelay(100);
    pollHeight = await getHeightWithRetry(serverUrl, logger);
  };
  return pollHeight;
}

var HeightQuery = {
  getHeightWithRetry: getHeightWithRetry,
  pollForHeightGtOrEq: pollForHeightGtOrEq
};

exports.LogsQuery = LogsQuery;
exports.BlockTimestampQuery = BlockTimestampQuery;
exports.HeightQuery = HeightQuery;
/* Time Not a pure module */
