// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var SDSL = require("../../bindings/SDSL.bs.js");
var Time = require("../../Time.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Utils = require("../../Utils.bs.js");
var Config = require("../../Config.bs.js");
var Hrtime = require("../../bindings/Hrtime.bs.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Logging = require("../../Logging.bs.js");
var JsSdsl = require("js-sdsl");
var Deferred = require("../../Deferred.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Converters = require("../../Converters.bs.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var DbFunctions = require("../../DbFunctions.bs.js");
var HyperSyncTypes = require("../hypersync/HyperSyncTypes.bs.js");
var ChainEventQueue = require("../ChainEventQueue.bs.js");
var ChainWorkerTypes = require("./ChainWorkerTypes.bs.js");
var ContractAddressingMap = require("../../ContractAddressingMap.bs.js");
var ContractInterfaceManager = require("../../ContractInterfaceManager.bs.js");

function Make(HyperSync) {
  var queryLogsPageWithBackoff = async function (backoffMsOnFailureOpt, callDepthOpt, maxCallDepthOpt, query, logger) {
    var backoffMsOnFailure = backoffMsOnFailureOpt !== undefined ? backoffMsOnFailureOpt : 200;
    var callDepth = callDepthOpt !== undefined ? callDepthOpt : 0;
    var maxCallDepth = maxCallDepthOpt !== undefined ? maxCallDepthOpt : 15;
    var e = await Curry._1(query, undefined);
    if (e.TAG === /* Ok */0) {
      return e._0;
    }
    var msg = HyperSyncTypes.queryErrorToMsq(e._0);
    if (callDepth < maxCallDepth) {
      Logging.childWarn(logger, {
            err: msg,
            msg: "Issue while running fetching of events from Hypersync endpoint. Will wait " + String(backoffMsOnFailure) + "ms and try again.",
            type: "EXPONENTIAL_BACKOFF"
          });
      await Time.resolvePromiseAfterDelay(backoffMsOnFailure);
      return await queryLogsPageWithBackoff((backoffMsOnFailure << 1), callDepth + 1 | 0, undefined, query, logger);
    } else {
      Logging.childError(logger, {
            err: msg,
            msg: "Issue while running fetching batch of events from Hypersync endpoint. Attempted query a maximum of " + String(maxCallDepth) + " times. Will NOT retry.",
            type: "EXPONENTIAL_BACKOFF_MAX_DEPTH"
          });
      return Js_exn.raiseError(msg);
    }
  };
  var Helpers = {
    queryLogsPageWithBackoff: queryLogsPageWithBackoff
  };
  var stopFetchingEvents = function (self) {
    self.shouldContinueFetching = false;
    if (self.isFetching) {
      return new Promise((function (resolve, _reject) {
                    self.hasStoppedFetchingCallBack = (function (param) {
                        resolve(undefined);
                      });
                  }));
    } else {
      return Promise.resolve(undefined);
    }
  };
  var make = function (caughtUpToHeadHook, contractAddressMapping, chainConfig) {
    var caughtUpToHeadHook$1 = caughtUpToHeadHook !== undefined ? caughtUpToHeadHook : (function (_self) {
          return Promise.resolve(undefined);
        });
    var logger = Logging.createChild({
          chainId: chainConfig.chainId,
          workerType: "Hypersync",
          loggerFor: "Used only in logging regestration of static contract addresses"
        });
    var contractAddressMapping$1;
    if (contractAddressMapping !== undefined) {
      contractAddressMapping$1 = contractAddressMapping;
    } else {
      var m = ContractAddressingMap.make(undefined);
      ContractAddressingMap.registerStaticAddresses(m, chainConfig, logger);
      contractAddressMapping$1 = m;
    }
    var syncSource = chainConfig.syncSource;
    var serverUrl;
    switch (syncSource.TAG | 0) {
      case /* Rpc */0 :
          var exn = {
            RE_EXN_ID: ChainWorkerTypes.IncorrectSyncSource,
            _1: syncSource
          };
          Logging.childErrorWithExn(logger, exn, {
                msg: "Passed incorrect sync source to a hypersync worker",
                syncSource: syncSource
              });
          throw exn;
      case /* Skar */1 :
      case /* EthArchive */2 :
          serverUrl = syncSource._0;
          break;
      
    }
    return {
            latestFetchedBlockNumber: Promise.resolve(0),
            latestFetchedBlockTimestamp: 0,
            hasNewDynamicContractRegistrations: Promise.resolve(false),
            shouldContinueFetching: true,
            isFetching: false,
            hasStoppedFetchingCallBack: (function (param) {
                
              }),
            newRangeQueriedCallBacks: new JsSdsl.Queue(),
            contractAddressMapping: contractAddressMapping$1,
            chainConfig: chainConfig,
            serverUrl: serverUrl,
            caughtUpToHeadHook: caughtUpToHeadHook$1
          };
  };
  var startWorker = async function (self, startBlock, logger, fetchedEventQueue) {
    Logging.childInfo(logger, "Hypersync worker starting");
    var serverUrl = self.serverUrl;
    var chainConfig = self.chainConfig;
    var contractAddressMapping = self.contractAddressMapping;
    var initialHeight = await Curry._2(HyperSync.getHeightWithRetry, self.serverUrl, logger);
    var currentHeight = {
      contents: initialHeight
    };
    var fromBlock = {
      contents: startBlock
    };
    DbFunctions.ChainMetadata.setChainMetadataRow(chainConfig.chainId, startBlock, initialHeight);
    var checkReadyToContinue = async function (param) {
      if (fromBlock.contents >= currentHeight.contents) {
        Logging.childTrace(logger, "Worker is caught up, awaiting new blocks");
        currentHeight.contents = await Curry._3(HyperSync.pollForHeightGtOrEq, self.serverUrl, fromBlock.contents, logger);
        DbFunctions.ChainMetadata.setChainMetadataRow(chainConfig.chainId, startBlock, currentHeight.contents);
      }
      return true;
    };
    var getNextPage = async function (param) {
      await checkReadyToContinue(undefined);
      var contractInterfaceManager = ContractInterfaceManager.make(chainConfig, contractAddressMapping);
      var contractAddressesAndtopics = ContractInterfaceManager.getAllContractTopicsAndAddresses(contractInterfaceManager);
      var startFetchingBatchTimeRef = Hrtime.makeTimer(undefined);
      var pageUnsafe = await queryLogsPageWithBackoff(undefined, undefined, undefined, (function (param) {
              return Curry._4(HyperSync.queryLogsPage, self.serverUrl, fromBlock.contents, currentHeight.contents, contractAddressesAndtopics);
            }), logger);
      var pageFetchTime = Hrtime.intFromMillis(Hrtime.toMillis(Hrtime.timeSince(startFetchingBatchTimeRef)));
      return {
              contractInterfaceManager: contractInterfaceManager,
              page: pageUnsafe,
              pageFetchTime: pageFetchTime
            };
    };
    var initialPagePromise = getNextPage(undefined);
    var nextPagePromise = initialPagePromise;
    while(self.shouldContinueFetching) {
      var startFetchingBatchTimeRef = Hrtime.makeTimer(undefined);
      var match = await nextPagePromise;
      var pageFetchTime = match.pageFetchTime;
      var pageUnsafe = match.page;
      var contractInterfaceManager = match.contractInterfaceManager;
      var currentBatchFromBlock = fromBlock.contents;
      if (pageUnsafe.archiveHeight > currentHeight.contents) {
        DbFunctions.ChainMetadata.setChainMetadataRow(chainConfig.chainId, startBlock, pageUnsafe.archiveHeight);
        currentHeight.contents = pageUnsafe.archiveHeight;
      }
      fromBlock.contents = pageUnsafe.nextBlock;
      nextPagePromise = getNextPage(undefined);
      Logging.childTrace(logger, {
            message: "Retrieved event page from server",
            fromBlock: currentBatchFromBlock,
            toBlock: pageUnsafe.nextBlock - 1 | 0,
            "number of logs": pageUnsafe.items.length
          });
      var heighestBlockQueried = pageUnsafe.nextBlock - 1 | 0;
      var getHeighestBlockAndTimestampWithDefault = (function(heighestBlockQueried){
      return function getHeighestBlockAndTimestampWithDefault($$default) {
        return Curry._3(HyperSync.queryBlockTimestampsPage, serverUrl, heighestBlockQueried, heighestBlockQueried).then(function (res) {
                    return Belt_Result.mapWithDefault(res, $$default, (function (page) {
                                  var lastBlockInRangeQueried = Belt_Array.get(page.items, page.items.length - 1 | 0);
                                  return Belt_Option.getWithDefault(lastBlockInRangeQueried, $$default);
                                }));
                  });
      }
      }(heighestBlockQueried));
      var logItemsHeighestBlockOpt = Belt_Option.map(Belt_Array.get(pageUnsafe.items, pageUnsafe.items.length - 1 | 0), (function (item) {
              return {
                      timestamp: item.blockTimestamp,
                      blockNumber: item.log.blockNumber
                    };
            }));
      var heighestBlockQueriedPromise = logItemsHeighestBlockOpt !== undefined ? (
          logItemsHeighestBlockOpt.blockNumber === heighestBlockQueried ? Promise.resolve(logItemsHeighestBlockOpt) : getHeighestBlockAndTimestampWithDefault({
                  timestamp: logItemsHeighestBlockOpt.timestamp,
                  blockNumber: heighestBlockQueried
                })
        ) : getHeighestBlockAndTimestampWithDefault({
              timestamp: self.latestFetchedBlockTimestamp,
              blockNumber: heighestBlockQueried
            });
      if (await self.hasNewDynamicContractRegistrations) {
        self.hasNewDynamicContractRegistrations = Promise.resolve(false);
        Logging.childTrace(logger, {
              message: "Dropping invalid batch due to new dynamic contract registration",
              "page fetch time elapsed (ms)": pageFetchTime
            });
      } else {
        var match$1 = Utils.createPromiseWithHandles(undefined);
        self.latestFetchedBlockNumber = match$1.pendingPromise;
        var parsingTimeRef = Hrtime.makeTimer(undefined);
        var parsedQueueItems = await Deferred.asPromise(Deferred.mapArrayDeferred(pageUnsafe.items, (function(contractInterfaceManager){
                return function (item, resolve, reject) {
                  var parsed = Converters.parseEvent(item.log, item.blockTimestamp, contractInterfaceManager);
                  if (parsed.TAG === /* Ok */0) {
                    return Curry._1(resolve, {
                                timestamp: item.blockTimestamp,
                                chainId: chainConfig.chainId,
                                blockNumber: item.log.blockNumber,
                                logIndex: item.log.index,
                                event: parsed._0
                              });
                  } else {
                    return Curry._1(reject, {
                                RE_EXN_ID: Converters.ParseEventErrorExn,
                                _1: parsed._0
                              });
                  }
                }
                }(contractInterfaceManager))));
        var parsingTimeElapsed = Hrtime.intFromMillis(Hrtime.toMillis(Hrtime.timeSince(parsingTimeRef)));
        var queuePushingTimeRef = Hrtime.makeTimer(undefined);
        for(var i = 0 ,i_finish = parsedQueueItems.length; i < i_finish; ++i){
          var queueItem = Caml_array.get(parsedQueueItems, i);
          await ChainEventQueue.awaitQueueSpaceAndPushItem(fetchedEventQueue, queueItem);
          SDSL.Queue.popForEach(self.newRangeQueriedCallBacks, (function (callback) {
                  Curry._1(callback, undefined);
                }));
        }
        var queuePushingTimeElapsed = Hrtime.intFromMillis(Hrtime.toMillis(Hrtime.timeSince(queuePushingTimeRef)));
        var match$2 = await heighestBlockQueriedPromise;
        self.latestFetchedBlockTimestamp = match$2.timestamp;
        Curry._1(match$1.resolve, match$2.blockNumber);
        SDSL.Queue.popForEach(self.newRangeQueriedCallBacks, (function (callback) {
                Curry._1(callback, undefined);
              }));
        var totalTimeElapsed = Hrtime.intFromMillis(Hrtime.toMillis(Hrtime.timeSince(startFetchingBatchTimeRef)));
        Logging.childTrace(logger, {
              message: "Finished page range",
              fromBlock: currentBatchFromBlock,
              toBlock: await self.latestFetchedBlockNumber,
              "total time elapsed (ms)": totalTimeElapsed,
              "page fetch time (ms)": pageFetchTime,
              "parsing time (ms)": parsingTimeElapsed,
              "average parse time per log (ms)": parsingTimeElapsed / parsedQueueItems.length,
              "push to queue time (ms)": queuePushingTimeElapsed
            });
      }
    };
  };
  var startFetchingEvents = async function (self, logger, fetchedEventQueue) {
    Logging.childTrace(logger, "Starting event fetching on Skar worker");
    var chainConfig = self.chainConfig;
    var contractAddressMapping = self.contractAddressMapping;
    var latestProcessedBlock = await DbFunctions.EventSyncState.getLatestProcessedBlockNumber(chainConfig.chainId);
    var startBlock = Belt_Option.mapWithDefault(latestProcessedBlock, chainConfig.startBlock, (function (latestProcessedBlock) {
            return latestProcessedBlock + 1 | 0;
          }));
    Logging.childTrace(logger, {
          msg: "Starting fetching events for chain.",
          startBlock: startBlock,
          latestProcessedBlock: latestProcessedBlock
        });
    var dynamicContracts = await DbFunctions.DynamicContractRegistry.readDynamicContractsOnChainIdAtOrBeforeBlock(DbFunctions.sql, chainConfig.chainId, startBlock);
    Belt_Array.forEach(dynamicContracts, (function (param) {
            ContractAddressingMap.addAddress(contractAddressMapping, param.contract_type, param.contract_address);
          }));
    await startWorker(self, startBlock, logger, fetchedEventQueue);
    return Curry._1(self.hasStoppedFetchingCallBack, undefined);
  };
  var addNewRangeQueriedCallback = function (self) {
    return ChainEventQueue.insertCallbackAwaitPromise(self.newRangeQueriedCallBacks);
  };
  var getLatestFetchedBlockTimestamp = function (self) {
    return self.latestFetchedBlockTimestamp;
  };
  var fetchArbitraryEvents = async function (self, dynamicContracts, fromBlock, fromLogIndex, toBlock, logger) {
    Logging.childTrace(logger, {
          message: "Fetching Arbitrary Events",
          contracts: dynamicContracts,
          fromBlock: fromBlock,
          fromLogIndex: fromLogIndex,
          toBlock: toBlock
        });
    var contractInterfaceManager = ContractInterfaceManager.combineInterfaceManagers(Belt_Array.map(dynamicContracts, (function (param) {
                var chainId = param.chain_id;
                var c = Js_dict.get(Config.config, String(chainId));
                var chainConfig;
                if (c !== undefined) {
                  chainConfig = c;
                } else {
                  var exn = {
                    RE_EXN_ID: ChainWorkerTypes.UndefinedChainConfig,
                    _1: chainId
                  };
                  Logging.childErrorWithExn(logger, exn, "Could not find chain config for given ChainId");
                  throw exn;
                }
                return ContractInterfaceManager.makeFromSingleContract(chainConfig, param.contract_address, param.contract_type);
              })));
    var queueItems = [];
    var fromBlockRef = {
      contents: fromBlock
    };
    while(fromBlockRef.contents < toBlock) {
      var contractAddressesAndtopics = ContractInterfaceManager.getAllContractTopicsAndAddresses(contractInterfaceManager);
      var pageUnsafe = await queryLogsPageWithBackoff(undefined, undefined, undefined, (function(contractAddressesAndtopics){
          return function (param) {
            return Curry._4(HyperSync.queryLogsPage, self.serverUrl, fromBlockRef.contents, toBlock, contractAddressesAndtopics);
          }
          }(contractAddressesAndtopics)), logger);
      var parsedItems = await Deferred.asPromise(Deferred.mapArrayDeferred(pageUnsafe.items, (function (item, resolve, reject) {
                  var parsed = Converters.parseEvent(item.log, item.blockTimestamp, contractInterfaceManager);
                  if (parsed.TAG !== /* Ok */0) {
                    return Curry._1(reject, {
                                RE_EXN_ID: Converters.ParseEventErrorExn,
                                _1: parsed._0
                              });
                  }
                  var queueItem_timestamp = item.blockTimestamp;
                  var queueItem_chainId = self.chainConfig.chainId;
                  var queueItem_blockNumber = item.log.blockNumber;
                  var queueItem_logIndex = item.log.index;
                  var queueItem_event = parsed._0;
                  var queueItem = {
                    timestamp: queueItem_timestamp,
                    chainId: queueItem_chainId,
                    blockNumber: queueItem_blockNumber,
                    logIndex: queueItem_logIndex,
                    event: queueItem_event
                  };
                  Curry._1(resolve, queueItem);
                })));
      Belt_Array.forEach(parsedItems, (function (itemOpt) {
              Belt_Option.map(itemOpt, (function (item) {
                      return queueItems.push(item);
                    }));
            }));
      fromBlockRef.contents = pageUnsafe.nextBlock;
    };
    return queueItems;
  };
  var getContractAddressMapping = function (self) {
    return self.contractAddressMapping;
  };
  var addDynamicContractAndFetchMissingEvents = async function (self, dynamicContracts, fromBlock, fromLogIndex, logger) {
    var match = Utils.createPromiseWithHandles(undefined);
    self.hasNewDynamicContractRegistrations = match.pendingPromise;
    var unaddedDynamicContracts = Belt_Array.keep(dynamicContracts, (function (param) {
            return ContractAddressingMap.addAddressIfNotExists(self.contractAddressMapping, param.contract_type, param.contract_address);
          }));
    Curry._1(match.resolve, true);
    var toBlock = await self.latestFetchedBlockNumber;
    Logging.childTrace(logger, {
          message: "Registering dynamic contracts",
          contracts: dynamicContracts,
          fromBlock: fromBlock,
          fromLogIndex: fromLogIndex,
          toBlock: toBlock
        });
    return await fetchArbitraryEvents(self, unaddedDynamicContracts, fromBlock, fromLogIndex, toBlock, logger);
  };
  return {
          Helpers: Helpers,
          stopFetchingEvents: stopFetchingEvents,
          make: make,
          startWorker: startWorker,
          startFetchingEvents: startFetchingEvents,
          addNewRangeQueriedCallback: addNewRangeQueriedCallback,
          getLatestFetchedBlockTimestamp: getLatestFetchedBlockTimestamp,
          fetchArbitraryEvents: fetchArbitraryEvents,
          getContractAddressMapping: getContractAddressMapping,
          addDynamicContractAndFetchMissingEvents: addDynamicContractAndFetchMissingEvents
        };
}

exports.Make = Make;
/* SDSL Not a pure module */
