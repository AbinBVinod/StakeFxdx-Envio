// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var SDSL = require("./bindings/SDSL.bs.js");
var Time = require("./Time.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Logging = require("./Logging.bs.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Belt_MutableSetInt = require("rescript/lib/js/belt_MutableSetInt.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var LoaderTimeout = /* @__PURE__ */Caml_exceptions.create("LazyLoader.LoaderTimeout");

var s = Belt_MutableSetInt.make(undefined);

function make(loaderFn, cacheSizeOpt, loaderPoolSizeOpt, retryDelayMillisOpt, timeoutMillisOpt, metadata, param) {
  var cacheSize = cacheSizeOpt !== undefined ? cacheSizeOpt : 10000;
  var loaderPoolSize = loaderPoolSizeOpt !== undefined ? loaderPoolSizeOpt : 10;
  var retryDelayMillis = retryDelayMillisOpt !== undefined ? retryDelayMillisOpt : 5000;
  var timeoutMillis = timeoutMillisOpt !== undefined ? timeoutMillisOpt : 300000;
  return {
          _cacheSize: cacheSize,
          _loaderPoolSize: loaderPoolSize,
          _retryDelayMillis: retryDelayMillis,
          _timeoutMillis: timeoutMillis,
          externalPromises: {},
          resolvers: {},
          inProgress: Belt_MutableSetInt.make(undefined),
          loaderQueue: SDSL.PriorityQueue.makeAsc(undefined),
          loadedKeys: SDSL.PriorityQueue.makeAsc(undefined),
          loaderFn: loaderFn,
          metadata: metadata
        };
}

function deleteKey(_obj, _k) {
  ((delete _obj[_k]));
}

function timeoutAfter(timeoutMillis) {
  return Time.resolvePromiseAfterDelay(timeoutMillis).then(function (param) {
              return Promise.reject({
                          RE_EXN_ID: LoaderTimeout,
                          _1: "Query took longer than " + String(timeoutMillis / 1000 | 0) + " seconds"
                        });
            });
}

async function loadNext(am, k) {
  var key = String(k);
  Belt_MutableSetInt.add(am.inProgress, k);
  var awaitTaskPromiseAndLoadNextWithTimeout = async function (param) {
    var val = await Promise.race([
          Curry._1(am.loaderFn, k),
          timeoutAfter(am._timeoutMillis)
        ]);
    Belt_Option.map(Js_dict.get(am.resolvers, key), (function (r) {
            r(val);
          }));
    Belt_MutableSetInt.remove(am.inProgress, k);
    am.loadedKeys.push(k);
    if (am.loadedKeys.length > am._cacheSize) {
      var old = am.loadedKeys.pop();
      if (old !== undefined) {
        deleteKey(am.externalPromises, String(old));
      }
      
    }
    var next = am.loaderQueue.pop();
    if (next !== undefined) {
      return await loadNext(am, next);
    }
    
  };
  var tmp;
  var exit = 0;
  var val;
  try {
    val = await awaitTaskPromiseAndLoadNextWithTimeout(undefined);
    exit = 1;
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    Logging.error({
          err: err,
          msg: "EE1100: Top level promise timeout reached. Please review other errors or warnings in the code. This function will retry in " + String(am._retryDelayMillis / 1000 | 0) + " seconds. It is highly likely that your indexer isn't syncing on one or more chains currently. Also take a look at the \"suggestedFix\" in the metadata of this command",
          metadata: am.metadata
        });
    await Time.resolvePromiseAfterDelay(am._retryDelayMillis);
    tmp = awaitTaskPromiseAndLoadNextWithTimeout(undefined);
  }
  if (exit === 1) {
    tmp = Promise.resolve(undefined);
  }
  return await tmp;
}

function get(am, k) {
  var key = String(k);
  var x = Js_dict.get(am.externalPromises, key);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  var promise = new Promise((function (resolve, param) {
          am.resolvers[key] = resolve;
        }));
  am.externalPromises[key] = promise;
  if (Belt_MutableSetInt.size(am.inProgress) < am._loaderPoolSize) {
    loadNext(am, k);
  } else {
    am.loaderQueue.push(k);
  }
  return promise;
}

exports.LoaderTimeout = LoaderTimeout;
exports.s = s;
exports.make = make;
exports.deleteKey = deleteKey;
exports.timeoutAfter = timeoutAfter;
exports.loadNext = loadNext;
exports.get = get;
/* s Not a pure module */
