// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");

function runCallbacks(val, callbacks) {
  Belt_Array.forEach(callbacks.contents, (function (cb) {
          Curry._1(cb, val);
        }));
  callbacks.contents = [];
}

function makeEmpty(param) {
  var val = {
    contents: /* Pending */0
  };
  var thenCallbacks = {
    contents: []
  };
  var catchCallbacks = {
    contents: []
  };
  return {
          value: val,
          thenCallbacks: thenCallbacks,
          catchCallbacks: catchCallbacks,
          resolve: (function (res) {
              val.contents = {
                TAG: /* Resolved */0,
                _0: res
              };
              runCallbacks(res, thenCallbacks);
            }),
          reject: (function (exn) {
              val.contents = {
                TAG: /* Rejected */1,
                _0: exn
              };
              runCallbacks(exn, catchCallbacks);
            })
        };
}

function make(constructorFn) {
  var deferred = makeEmpty(undefined);
  setTimeout((function (param) {
          Curry._2(constructorFn, (function (val) {
                  Curry._1(deferred.resolve, val);
                }), (function (exn) {
                  Curry._1(deferred.reject, exn);
                }));
        }), 0);
  return deferred;
}

function thenResolve(self, cb) {
  var deferred = makeEmpty(undefined);
  var handleVal = function (val) {
    Curry._1(deferred.resolve, Curry._1(cb, val));
  };
  var val = self.value.contents;
  if (typeof val === "number") {
    self.thenCallbacks.contents.push(handleVal);
  } else if (val.TAG === /* Resolved */0) {
    Curry._1(deferred.resolve, Curry._1(cb, val._0));
  } else {
    Curry._1(deferred.reject, val._0);
  }
  return deferred;
}

function $$catch(self, cb) {
  var exn = self.value.contents;
  if (typeof exn !== "number") {
    if (exn.TAG === /* Resolved */0) {
      return self;
    } else {
      return Curry._1(cb, exn._0);
    }
  }
  var deferred = makeEmpty(undefined);
  var handleExn = function (exn) {
    thenResolve(Curry._1(cb, exn), (function (val) {
            Curry._1(deferred.resolve, val);
          }));
  };
  self.catchCallbacks.contents.push(handleExn);
  return deferred;
}

function resolve(val) {
  var deferred = makeEmpty(undefined);
  Curry._1(deferred.resolve, val);
  return deferred;
}

function reject(exn) {
  var deferred = makeEmpty(undefined);
  Curry._1(deferred.reject, exn);
  return deferred;
}

function all(defs) {
  var deferred = makeEmpty(undefined);
  var vals = [];
  var currentIndex = {
    contents: 0
  };
  var pollForNewVals = function (param) {
    var breakLoop = false;
    while(!breakLoop) {
      var item = Belt_Array.get(defs, currentIndex.contents);
      if (item !== undefined) {
        var itemResolveCb = function (val) {
          vals.push(val);
          currentIndex.contents = currentIndex.contents + 1 | 0;
        };
        var val = item.value.contents;
        if (typeof val === "number") {
          thenResolve(item, (function (val) {
                  itemResolveCb(val);
                  pollForNewVals(undefined);
                }));
          breakLoop = true;
        } else if (val.TAG === /* Resolved */0) {
          itemResolveCb(val._0);
        } else {
          Curry._1(deferred.reject, val._0);
          breakLoop = true;
        }
      } else {
        Curry._1(deferred.resolve, vals);
        breakLoop = true;
      }
    };
  };
  pollForNewVals(undefined);
  return deferred;
}

function mapArrayDeferred(arr, cb) {
  return all(Belt_Array.map(arr, (function (item) {
                    return make(Curry._1(cb, item));
                  })));
}

function asPromise(self) {
  return new Promise((function (res, rej) {
                $$catch(thenResolve(self, (function (val) {
                            res(val);
                          })), (function (exn) {
                        rej(exn);
                        return reject(exn);
                      }));
              }));
}

exports.make = make;
exports.thenResolve = thenResolve;
exports.$$catch = $$catch;
exports.resolve = resolve;
exports.reject = reject;
exports.all = all;
exports.mapArrayDeferred = mapArrayDeferred;
exports.asPromise = asPromise;
/* No side effect */
