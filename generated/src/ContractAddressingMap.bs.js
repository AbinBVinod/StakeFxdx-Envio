// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Ethers = require("./bindings/Ethers.bs.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Logging = require("./Logging.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Belt_SetString = require("rescript/lib/js/belt_SetString.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

var UndefinedContractName = /* @__PURE__ */Caml_exceptions.create("ContractAddressingMap.UndefinedContractName");

var UndefinedContractAddress = /* @__PURE__ */Caml_exceptions.create("ContractAddressingMap.UndefinedContractAddress");

function addAddress(map, name, address) {
  map.nameByAddress[Ethers.ethAddressToString(address)] = name;
  var oldAddresses = Belt_Option.getWithDefault(Js_dict.get(map.addressesByName, name), undefined);
  var newAddresses = Belt_SetString.add(oldAddresses, Ethers.ethAddressToString(address));
  map.addressesByName[name] = newAddresses;
}

function addAddressIfNotExists(map, name, address) {
  var addressIsNew = Belt_Option.mapWithDefault(Js_dict.get(map.nameByAddress, Ethers.ethAddressToString(address)), true, (function (expectedName) {
          return expectedName !== name;
        }));
  if (addressIsNew) {
    addAddress(map, name, address);
  }
  return addressIsNew;
}

function getAddresses(map, name) {
  return Js_dict.get(map.addressesByName, name);
}

function getName(map, address) {
  return Js_dict.get(map.nameByAddress, address);
}

function make(param) {
  return {
          nameByAddress: {},
          addressesByName: {}
        };
}

function registerStaticAddresses(mapping, chainConfig, logger) {
  Belt_Array.forEach(chainConfig.contracts, (function (contract) {
          Belt_Array.forEach(contract.addresses, (function (address) {
                  Logging.childTrace(logger, {
                        msg: "adding contract address",
                        contractName: contract.name,
                        address: address
                      });
                  addAddress(mapping, contract.name, address);
                }));
        }));
}

function getContractNameFromAddress(mapping, contractAddress) {
  var address = Ethers.ethAddressToString(contractAddress);
  return Js_dict.get(mapping.nameByAddress, address);
}

function getContractNameFromAddressUnsafe(mapping, contractAddress, logger) {
  var address = Ethers.ethAddressToString(contractAddress);
  var contractName = Js_dict.get(mapping.nameByAddress, address);
  if (contractName !== undefined) {
    return contractName;
  }
  Logging.childError(logger, "contract address " + Ethers.ethAddressToString(contractAddress) + "  was not found in address store");
  throw {
        RE_EXN_ID: UndefinedContractAddress,
        _1: contractAddress,
        Error: new Error()
      };
}

function stringsToAddresses(prim) {
  return prim;
}

function getAddressesFromContractName(mapping, contractName) {
  var addresses = Js_dict.get(mapping.addressesByName, contractName);
  return Belt_SetString.toArray(addresses !== undefined ? Caml_option.valFromOption(addresses) : undefined);
}

function getAllAddresses(mapping) {
  return Object.keys(mapping.nameByAddress);
}

exports.UndefinedContractName = UndefinedContractName;
exports.UndefinedContractAddress = UndefinedContractAddress;
exports.addAddress = addAddress;
exports.addAddressIfNotExists = addAddressIfNotExists;
exports.getAddresses = getAddresses;
exports.getName = getName;
exports.make = make;
exports.registerStaticAddresses = registerStaticAddresses;
exports.getContractNameFromAddress = getContractNameFromAddress;
exports.getContractNameFromAddressUnsafe = getContractNameFromAddressUnsafe;
exports.stringsToAddresses = stringsToAddresses;
exports.getAddressesFromContractName = getAddressesFromContractName;
exports.getAllAddresses = getAllAddresses;
/* Ethers Not a pure module */
