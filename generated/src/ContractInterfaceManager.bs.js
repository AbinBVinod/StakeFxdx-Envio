// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Viem = require("./bindings/Viem.bs.js");
var Ethers = require("./bindings/Ethers.bs.js");
var Ethers$1 = require("ethers");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Logging = require("./Logging.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var ContractAddressingMap = require("./ContractAddressingMap.bs.js");

function make(chainConfig, contractAddressMapping) {
  var contractNameInterfaceMapping = {};
  Belt_Array.forEach(chainConfig.contracts, (function (contract) {
          var abi = contract.abi;
          var $$interface = new (Ethers$1.ethers.Interface)(abi);
          contractNameInterfaceMapping[contract.name] = {
            interface: $$interface,
            abi: abi
          };
        }));
  return {
          contractAddressMapping: contractAddressMapping,
          contractNameInterfaceMapping: contractNameInterfaceMapping
        };
}

function getInterfaceByName(self, contractName) {
  return Js_dict.get(self.contractNameInterfaceMapping, contractName);
}

function getInterfaceByAddress(self, contractAddress) {
  return Belt_Option.flatMap(ContractAddressingMap.getContractNameFromAddress(self.contractAddressMapping, contractAddress), (function (contractName) {
                return Js_dict.get(self.contractNameInterfaceMapping, contractName);
              }));
}

var UndefinedInterface = /* @__PURE__ */Caml_exceptions.create("ContractInterfaceManager.UndefinedInterface");

var UndefinedContract = /* @__PURE__ */Caml_exceptions.create("ContractInterfaceManager.UndefinedContract");

function makeFromSingleContract(chainConfig, contractAddress, contractName) {
  var c = chainConfig.contracts.find(function (configContract) {
        return configContract.name === contractName;
      });
  var contract;
  if (c !== undefined) {
    contract = c;
  } else {
    var exn = {
      RE_EXN_ID: UndefinedContract,
      _1: contractName
    };
    Logging.errorWithExn(exn, "EE900: Unexpected undefined contract. Please verify the contract name defined in the config.yaml file.");
    throw exn;
  }
  var contractNameInterfaceMapping = {};
  var contractAddressMapping = ContractAddressingMap.make(undefined);
  var abi = contract.abi;
  var $$interface = new (Ethers$1.ethers.Interface)(abi);
  contractNameInterfaceMapping[contract.name] = {
    interface: $$interface,
    abi: abi
  };
  ContractAddressingMap.addAddress(contractAddressMapping, contract.name, contractAddress);
  return {
          contractAddressMapping: contractAddressMapping,
          contractNameInterfaceMapping: contractNameInterfaceMapping
        };
}

function combineInterfaceManagers(managers) {
  var contractAddressMapping = ContractAddressingMap.make(undefined);
  var contractNameInterfaceMapping = {};
  Belt_Array.forEach(managers, (function (manager) {
          Belt_Array.forEach(Js_dict.values(manager.contractAddressMapping.nameByAddress), (function (contractName) {
                  Belt_Array.forEach(ContractAddressingMap.getAddressesFromContractName(manager.contractAddressMapping, contractName), (function (contractAddress) {
                          ContractAddressingMap.addAddress(contractAddressMapping, contractName, contractAddress);
                        }));
                }));
          Belt_Array.forEach(Js_dict.entries(manager.contractNameInterfaceMapping), (function (param) {
                  contractNameInterfaceMapping[param[0]] = param[1];
                }));
        }));
  return {
          contractAddressMapping: contractAddressMapping,
          contractNameInterfaceMapping: contractNameInterfaceMapping
        };
}

function getAllTopicsAndAddresses(self) {
  var topics = [];
  var addresses = [];
  Belt_Array.forEach(Object.keys(self.contractAddressMapping.addressesByName), (function (contractName) {
          var interfaceOpt = Js_dict.get(self.contractNameInterfaceMapping, contractName);
          if (interfaceOpt !== undefined) {
            interfaceOpt.interface.forEachEvent(function (eventFragment, _i) {
                  topics.push(eventFragment.topicHash);
                });
            return Belt_Array.forEach(ContractAddressingMap.getAddressesFromContractName(self.contractAddressMapping, contractName), (function (address) {
                          addresses.push(address);
                        }));
          }
          var exn = {
            RE_EXN_ID: UndefinedInterface,
            _1: contractName
          };
          Logging.errorWithExn(exn, "EE901: Unexpected case. Contract name does not exist in interface mapping.");
          throw exn;
        }));
  return {
          addresses: addresses,
          topics: topics
        };
}

function getAllContractTopicsAndAddresses(self) {
  return Belt_Array.map(Object.keys(self.contractAddressMapping.addressesByName), (function (contractName) {
                var interfaceOpt = Js_dict.get(self.contractNameInterfaceMapping, contractName);
                if (interfaceOpt !== undefined) {
                  var topics = [];
                  interfaceOpt.interface.forEachEvent(function (eventFragment, _i) {
                        topics.push(eventFragment.topicHash);
                      });
                  var addresses = [];
                  Belt_Array.forEach(ContractAddressingMap.getAddressesFromContractName(self.contractAddressMapping, contractName), (function (address) {
                          addresses.push(address);
                        }));
                  return {
                          address: addresses,
                          topics: [topics]
                        };
                }
                var exn = {
                  RE_EXN_ID: UndefinedInterface,
                  _1: contractName
                };
                Logging.errorWithExn(exn, "EE901: Unexpected case. Contract name does not exist in interface mapping.");
                throw exn;
              }));
}

function getContractNameFromAddress(self, contractAddress) {
  return ContractAddressingMap.getContractNameFromAddress(self.contractAddressMapping, contractAddress);
}

function getCombinedEthersFilter(self, fromBlock, toBlock) {
  var match = getAllTopicsAndAddresses(self);
  var topLevelTopics = [match.topics];
  return {
          address: match.addresses,
          topics: topLevelTopics,
          fromBlock: Ethers.BlockTag.blockTagFromVariant({
                TAG: /* BlockNumber */1,
                _0: fromBlock
              }),
          toBlock: Ethers.BlockTag.blockTagFromVariant({
                TAG: /* BlockNumber */1,
                _0: toBlock
              })
        };
}

function parseLogEthers(self, log) {
  var interfaceOpt = Belt_Option.map(getInterfaceByAddress(self, log.address), (function (mapping) {
          return mapping.interface;
        }));
  if (interfaceOpt === undefined) {
    return {
            TAG: /* Error */1,
            _0: {
              TAG: /* UndefinedInterface */1,
              _0: log.address
            }
          };
  }
  var e = Ethers.Interface.parseLog(Caml_option.valFromOption(interfaceOpt), log);
  if (e.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: e._0
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: {
              TAG: /* ParseError */0,
              _0: e._0
            }
          };
  }
}

function parseLogViem(self, log) {
  var abiOpt = Belt_Option.map(getInterfaceByAddress(self, log.address), (function (mapping) {
          return mapping.abi;
        }));
  if (abiOpt === undefined) {
    return {
            TAG: /* Error */1,
            _0: {
              TAG: /* UndefinedInterface */1,
              _0: log.address
            }
          };
  }
  var viemLog_abi = Caml_option.valFromOption(abiOpt);
  var viemLog_data = log.data;
  var viemLog_topics = log.topics;
  var viemLog = {
    abi: viemLog_abi,
    data: viemLog_data,
    topics: viemLog_topics
  };
  var e = Viem.decodeEventLog(viemLog);
  if (e.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: e._0
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: {
              TAG: /* ParseError */0,
              _0: e._0
            }
          };
  }
}

exports.make = make;
exports.getInterfaceByName = getInterfaceByName;
exports.getInterfaceByAddress = getInterfaceByAddress;
exports.UndefinedInterface = UndefinedInterface;
exports.UndefinedContract = UndefinedContract;
exports.makeFromSingleContract = makeFromSingleContract;
exports.combineInterfaceManagers = combineInterfaceManagers;
exports.getAllTopicsAndAddresses = getAllTopicsAndAddresses;
exports.getAllContractTopicsAndAddresses = getAllContractTopicsAndAddresses;
exports.getContractNameFromAddress = getContractNameFromAddress;
exports.getCombinedEthersFilter = getCombinedEthersFilter;
exports.parseLogEthers = parseLogEthers;
exports.parseLogViem = parseLogViem;
/* Viem Not a pure module */
