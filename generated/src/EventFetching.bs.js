// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("rescript/lib/js/caml.js");
var Time = require("./Time.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Ethers = require("./bindings/Ethers.bs.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Logging = require("./Logging.bs.js");
var $$Promise = require("@ryyppy/rescript-promise/src/Promise.bs.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Converters = require("./Converters.bs.js");
var LazyLoader = require("./LazyLoader.bs.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var ContractInterfaceManager = require("./ContractInterfaceManager.bs.js");

var QueryTimout = /* @__PURE__ */Caml_exceptions.create("EventFetching.QueryTimout");

function getUnwrappedBlock(provider, blockNumber) {
  return provider.getBlock(blockNumber).then(function (blockNullable) {
              if (blockNullable == null) {
                return Promise.reject(Js_exn.raiseError("RPC returned null for blockNumber " + String(blockNumber) + ""));
              } else {
                return Promise.resolve(blockNullable);
              }
            });
}

async function getUnwrappedBlockWithBackoff(provider, blockNumber, backoffMsOnFailure) {
  try {
    return await getUnwrappedBlock(provider, blockNumber);
  }
  catch (raw_err){
    var err = Caml_js_exceptions.internalToOCamlException(raw_err);
    Logging.warn({
          err: err,
          msg: "Issue while running fetching batch of events from the RPC. Will wait " + String(backoffMsOnFailure) + "ms and try again.",
          type: "EXPONENTIAL_BACKOFF"
        });
    await Time.resolvePromiseAfterDelay(backoffMsOnFailure);
    return await getUnwrappedBlockWithBackoff(provider, blockNumber, (backoffMsOnFailure << 1));
  }
}

function makeCombinedEventFilterQuery(provider, contractInterfaceManager, fromBlock, toBlock, logger) {
  var combinedFilter = ContractInterfaceManager.getCombinedEthersFilter(contractInterfaceManager, fromBlock, toBlock);
  var numBlocks = (toBlock - fromBlock | 0) + 1 | 0;
  Logging.childTrace(logger, {
        msg: "Initiating Combined Query Filter",
        from: fromBlock,
        to: toBlock,
        numBlocks: numBlocks
      });
  return $$Promise.$$catch(provider.getLogs(Ethers.CombinedFilter.combinedFilterToFilter(combinedFilter)).then(function (res) {
                  Logging.childTrace(logger, {
                        msg: "Successful Combined Query Filter",
                        from: fromBlock,
                        to: toBlock,
                        numBlocks: numBlocks
                      });
                  return res;
                }), (function (err) {
                Logging.childWarn(logger, {
                      msg: "Failed Combined Query Filter from block",
                      from: fromBlock,
                      to: toBlock,
                      numBlocks: numBlocks
                    });
                return Promise.reject(err);
              }));
}

var RpcEventParsing = /* @__PURE__ */Caml_exceptions.create("EventFetching.RpcEventParsing");

function convertLogs(logs, blockLoader, contractInterfaceManager, chainId, logger) {
  Logging.childTrace(logger, {
        msg: "Handling of logs",
        numberLogs: logs.length
      });
  return Belt_Array.map(logs, (function (log) {
                var blockPromise = LazyLoader.get(blockLoader, log.blockNumber);
                var timestampPromise = blockPromise.then(function (block) {
                      return block.timestamp;
                    });
                return {
                        timestampPromise: timestampPromise,
                        chainId: chainId,
                        blockNumber: log.blockNumber,
                        logIndex: log.index,
                        eventPromise: timestampPromise.then(function (blockTimestamp) {
                              var parsed = Converters.parseEvent(log, blockTimestamp, contractInterfaceManager);
                              if (parsed.TAG === /* Ok */0) {
                                return parsed._0;
                              }
                              var ex_1 = parsed._0;
                              var ex = {
                                RE_EXN_ID: RpcEventParsing,
                                _1: ex_1
                              };
                              Logging.childErrorWithExn(logger, ex, "Failed to parse event from RPC. Double c");
                              throw ex;
                            })
                      };
              }));
}

function applyConditionalFunction(value, condition, callback) {
  if (condition) {
    return Curry._1(callback, value);
  } else {
    return value;
  }
}

async function queryEventsWithCombinedFilter(contractInterfaceManager, fromBlock, toBlock, minFromBlockLogIndexOpt, blockLoader, provider, chainId, logger, param) {
  var minFromBlockLogIndex = minFromBlockLogIndexOpt !== undefined ? minFromBlockLogIndexOpt : 0;
  var combinedFilterRes = await makeCombinedEventFilterQuery(provider, contractInterfaceManager, fromBlock, toBlock, logger);
  var logs = applyConditionalFunction(combinedFilterRes, minFromBlockLogIndex > 0, (function (arrLogs) {
          return Belt_Array.keep(arrLogs, (function (log) {
                        if (log.blockNumber > fromBlock) {
                          return true;
                        } else if (log.blockNumber === fromBlock) {
                          return log.index >= minFromBlockLogIndex;
                        } else {
                          return false;
                        }
                      }));
        }));
  return convertLogs(logs, blockLoader, contractInterfaceManager, chainId, logger);
}

async function getContractEventsOnFilters(contractInterfaceManager, fromBlock, toBlock, initialBlockInterval, minFromBlockLogIndexOpt, chainId, rpcConfig, blockLoader, logger, param) {
  var minFromBlockLogIndex = minFromBlockLogIndexOpt !== undefined ? minFromBlockLogIndexOpt : 0;
  var sc = rpcConfig.syncConfig;
  var fromBlockRef = {
    contents: fromBlock
  };
  var currentBlockInterval = initialBlockInterval;
  var events = [];
  while(fromBlockRef.contents <= toBlock) {
    Logging.childTrace(logger, "continuing to process...");
    var executeQuery = function (blockInterval) {
      var queryTimoutPromise = Time.resolvePromiseAfterDelay(sc.queryTimeoutMillis).then(function (param) {
            return Promise.reject({
                        RE_EXN_ID: QueryTimout,
                        _1: "Query took longer than " + String(sc.queryTimeoutMillis / 1000 | 0) + " seconds"
                      });
          });
      var upperBoundToBlock = (fromBlockRef.contents + blockInterval | 0) - 1 | 0;
      var nextToBlock = upperBoundToBlock < toBlock ? upperBoundToBlock : toBlock;
      var eventsPromise = queryEventsWithCombinedFilter(contractInterfaceManager, fromBlockRef.contents, nextToBlock, fromBlockRef.contents === fromBlock ? minFromBlockLogIndex : 0, blockLoader, rpcConfig.provider, chainId, logger, undefined).then(function (events) {
            return [
                    events,
                    (nextToBlock - fromBlockRef.contents | 0) + 1 | 0
                  ];
          });
      return $$Promise.$$catch(Promise.race([
                      queryTimoutPromise,
                      eventsPromise
                    ]), (function (err) {
                    Logging.childWarn(logger, {
                          msg: "Error getting events, will retry after backoff time",
                          backOffMilliseconds: sc.backoffMillis,
                          err: err
                        });
                    return Time.resolvePromiseAfterDelay(sc.backoffMillis).then(function (param) {
                                var nextBlockIntervalTry = blockInterval * sc.backoffMultiplicative | 0;
                                Logging.childTrace(logger, {
                                      msg: "Retrying query fromBlock and toBlock",
                                      fromBlock: fromBlock,
                                      toBlock: nextBlockIntervalTry
                                    });
                                return executeQuery(nextBlockIntervalTry);
                              });
                  }));
    };
    var match = await executeQuery(currentBlockInterval);
    var executedBlockInterval = match[1];
    var intervalEvents = match[0];
    events = Belt_Array.concat(events, intervalEvents);
    currentBlockInterval = Caml.int_min(executedBlockInterval + sc.accelerationAdditive | 0, sc.intervalCeiling);
    fromBlockRef.contents = fromBlockRef.contents + executedBlockInterval | 0;
    Logging.childTrace(logger, {
          msg: "Queried processAllEventsFromBlockNumber ",
          lastBlockProcessed: fromBlockRef.contents - 1 | 0,
          toBlock: toBlock,
          numEvents: intervalEvents.length
        });
  };
  return {
          eventBatchPromises: events,
          finalExecutedBlockInterval: currentBlockInterval
        };
}

exports.QueryTimout = QueryTimout;
exports.getUnwrappedBlock = getUnwrappedBlock;
exports.getUnwrappedBlockWithBackoff = getUnwrappedBlockWithBackoff;
exports.makeCombinedEventFilterQuery = makeCombinedEventFilterQuery;
exports.RpcEventParsing = RpcEventParsing;
exports.convertLogs = convertLogs;
exports.applyConditionalFunction = applyConditionalFunction;
exports.queryEventsWithCombinedFilter = queryEventsWithCombinedFilter;
exports.getContractEventsOnFilters = getContractEventsOnFilters;
/* Time Not a pure module */
